<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gravity Chess</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px 0;
      background-color: #1a1a1a;
      color: white;
      box-sizing: border-box;
    }

    .game-container {
      text-align: center;
      background-color: #2a2a2a;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      max-width: 90vw;
      width: fit-content;
    }

    h1 {
      color: #4a90e2;
      margin: 0 0 15px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      font-size: 2rem;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-template-rows: repeat(8, 70px);
      gap: 2px;
      margin: 15px auto;
      border: 3px solid #4a90e2;
      background-color: #333;
      position: relative;
    }

    .board::after {
      content: '';
      position: absolute;
      top: calc(50% - 1px);
      left: -3px;
      right: -3px;
      height: 4px;
      background-color: #000;
      z-index: 10;
      pointer-events: none;
    }

    .square {
      width: 70px;
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 56px;
      font-weight: bold;
      cursor: pointer;
      position: relative;
      border: 2px solid transparent;
    }

    .square.light {
      background-color: #f0d9b5;
      color: #333;
    }

    .square.dark {
      background-color: #b58863;
      color: #333;
    }

    .square.selected {
      border-color: #ff6b6b;
      background-color: #ffcccc;
    }

    .square.possible-move {
      border-color: #4ecdc4;
      background-color: #e8f8f5;
    }

    .square.in-check {
      background-color: #ff4d4d !important;
      border: 2px solid #ff0000;
    }

    .square.en-passant {
      border-color: #ffa500;
      background-color: #fff8dc;
    }

    .info {
      margin-top: 20px;
      padding: 15px;
      background-color: #333;
      border-radius: 10px;
      border-left: 4px solid #4a90e2;
    }

    .turn-info {
      font-size: 18px;
      font-weight: bold;
      color: #4a90e2;
      margin-bottom: 10px;
    }

    .rules {
      text-align: left;
      font-size: 14px;
      line-height: 1.5;
      color: #ccc;
    }

    .button {
      background-color: #4a90e2;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px;
      font-size: 16px;
      transition: background-color 0.3s;
    }

    .button:hover {
      background-color: #357abd;
    }

    .piece {
      transition: transform 0.1s ease;
      font-size: 64px;
      font-weight: bold;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .promotion-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .promotion-content {
      background-color: #2a2a2a;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      border: 3px solid #4a90e2;
    }

    .promotion-pieces {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }

    .promotion-piece {
      width: 80px;
      height: 80px;
      background-color: #f0d9b5;
      border: 2px solid #4a90e2;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .promotion-piece:hover {
      background-color: #4ecdc4;
      transform: scale(1.1);
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>⚡ Gravity Chess ⚡</h1>
    <div class="board" id="board"></div>
    <div class="info">
      <div class="turn-info" id="turn-info">White's Turn</div>
      <button class="button" onclick="resetGame()">New Game</button>
      <div class="rules">
        <strong>Gravity Chess Rules:</strong><br>
        • All pieces except pawns fall to their gravity zone<br>
        • White gravity: pieces fall to 4th rank<br>
        • Black gravity: pieces fall to 5th rank<br>
        • Pawns act as floors - pieces stop falling on pawns<br>
        • Pieces stack on each other in the same file<br>
        • Pawns promote to your choice of piece and then fall due to gravity<br>
        • En passant capture is available after enemy pawn moves 2 squares<br>
        • Capture the enemy king to win!
      </div>
    </div>
  </div>

  <div id="promotion-modal" class="promotion-modal hidden">
    <div class="promotion-content">
      <h2>Choose promotion piece:</h2>
      <div class="promotion-pieces" id="promotion-pieces"></div>
    </div>
  </div>

  <script>
    const initialBoard = [
      ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
      ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
      ['.', '.', '.', '.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.', '.', '.'],
      ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
      ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ];

    let board = [], selectedSquare = null, currentPlayer = 'white', possibleMoves = [], gameOver = false;
    let enPassantTarget = null; // {row, col} of square where en passant capture can happen
    let pendingPromotion = null; // {row, col, piece} waiting for promotion choice

    function initializeBoard() {
      board = JSON.parse(JSON.stringify(initialBoard));
      enPassantTarget = null;
      pendingPromotion = null;
    }

    function createBoard() {
      const boardElement = document.getElementById('board');
      boardElement.innerHTML = '';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          square.dataset.row = row;
          square.dataset.col = col;
          square.onclick = () => handleSquareClick(row, col);
          boardElement.appendChild(square);
        }
      }
    }

    function updateBoard() {
      const whiteKing = findKing('white');
      const blackKing = findKing('black');
      const whiteInCheck = whiteKing && isSquareUnderAttack(whiteKing.row, whiteKing.col, 'black');
      const blackInCheck = blackKing && isSquareUnderAttack(blackKing.row, blackKing.col, 'white');

      const squares = document.querySelectorAll('.square');
      squares.forEach((square, index) => {
        const row = Math.floor(index / 8);
        const col = index % 8;
        const piece = board[row][col];
        square.innerHTML = '';
        square.classList.remove('selected', 'possible-move', 'in-check', 'en-passant');

        if ((whiteInCheck && row === whiteKing.row && col === whiteKing.col) ||
            (blackInCheck && row === blackKing.row && col === blackKing.col)) {
          square.classList.add('in-check');
        }

        if (piece !== '.') {
          const pieceDiv = document.createElement('div');
          pieceDiv.className = 'piece';
          pieceDiv.textContent = pieceEmojis[piece] || piece;
          square.appendChild(pieceDiv);
        }

        if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col)
          square.classList.add('selected');
        if (possibleMoves.includes(`${row}-${col}`))
          square.classList.add('possible-move');
        if (possibleMoves.includes(`${row}-${col}-ep`))
          square.classList.add('en-passant');
      });
    }

    function updateTurnInfo() {
      document.getElementById('turn-info').textContent = `${currentPlayer === 'white' ? 'White' : 'Black'}'s Turn`;
    }

    function handleSquareClick(row, col) {
      if (gameOver) return;

      const piece = board[row][col];
      const moveKey = `${row}-${col}`;
      const enPassantKey = `${row}-${col}-ep`;

      if (selectedSquare && (possibleMoves.includes(moveKey) || possibleMoves.includes(enPassantKey))) {
        if (board[row][col].toLowerCase() === 'k') {
          gameOver = true;
          document.getElementById('turn-info').textContent = `${currentPlayer === 'white' ? 'White' : 'Black'} Wins! King Captured!`;
          document.getElementById('turn-info').style.color = '#ff6b6b';
        }

        const movingPiece = board[selectedSquare.row][selectedSquare.col];
        
        // Handle en passant capture
        if (possibleMoves.includes(enPassantKey)) {
          const captureRow = currentPlayer === 'white' ? row + 1 : row - 1;
          board[captureRow][col] = '.'; // Remove captured pawn
        }

        board[row][col] = movingPiece;
        board[selectedSquare.row][selectedSquare.col] = '.';

        // Check for pawn promotion
        if (movingPiece.toLowerCase() === 'p') {
          if ((movingPiece === 'P' && row === 0) || (movingPiece === 'p' && row === 7)) {
            pendingPromotion = { row, col, piece: movingPiece };
            showPromotionModal();
            return;
          }
          
          // Check for en passant setup (pawn moved 2 squares)
          if (Math.abs(selectedSquare.row - row) === 2) {
            enPassantTarget = { row: (selectedSquare.row + row) / 2, col };
          } else {
            enPassantTarget = null;
          }
        } else {
          enPassantTarget = null;
        }

        completeTurn();
      } else {
        if (piece !== '.' && isCurrentPlayerPiece(piece)) {
          selectedSquare = { row, col };
          possibleMoves = getValidMoves(row, col, piece);
        } else {
          selectedSquare = null;
          possibleMoves = [];
        }
        updateBoard();
      }
    }

    function completeTurn() {
      selectedSquare = null;
      possibleMoves = [];
      updateBoard();
      applyGravityWithAnimation(() => {
        if (!gameOver) {
          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          updateTurnInfo();
          updateBoard();
        }
      });
    }

    function showPromotionModal() {
      const modal = document.getElementById('promotion-modal');
      const piecesContainer = document.getElementById('promotion-pieces');
      
      modal.classList.remove('hidden');
      piecesContainer.innerHTML = '';

      const promotionPieces = currentPlayer === 'white' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
      
      promotionPieces.forEach(piece => {
        const pieceDiv = document.createElement('div');
        pieceDiv.className = 'promotion-piece';
        pieceDiv.textContent = pieceEmojis[piece];
        pieceDiv.onclick = () => selectPromotion(piece);
        piecesContainer.appendChild(pieceDiv);
      });
    }

    function selectPromotion(piece) {
      if (pendingPromotion) {
        board[pendingPromotion.row][pendingPromotion.col] = piece;
        pendingPromotion = null;
        document.getElementById('promotion-modal').classList.add('hidden');
        completeTurn();
      }
    }

    function isCurrentPlayerPiece(piece) {
      return currentPlayer === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase();
    }

    function findKing(color) {
      const kingChar = color === 'white' ? 'K' : 'k';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (board[row][col] === kingChar) return { row, col };
        }
      }
      return null;
    }

    function isSquareUnderAttack(row, col, byColor) {
      const opponent = byColor;
      const originalPlayer = currentPlayer;
      currentPlayer = opponent;

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece !== '.' && isCurrentPlayerPiece(piece)) {
            const moves = getValidMoves(r, c, piece);
            if (moves.some(move => move.startsWith(`${row}-${col}`))) {
              currentPlayer = originalPlayer;
              return true;
            }
          }
        }
      }

      currentPlayer = originalPlayer;
      return false;
    }

    function getValidMoves(row, col, piece) {
      const moves = [];
      const pieceType = piece.toLowerCase();
      
      switch (pieceType) {
        case 'p':
          const dir = piece === 'P' ? -1 : 1;
          const startRow = piece === 'P' ? 6 : 1;
          
          // Forward moves
          if (board[row + dir] && board[row + dir][col] === '.') {
            moves.push(`${row + dir}-${col}`);
            if (row === startRow && board[row + 2 * dir][col] === '.') {
              moves.push(`${row + 2 * dir}-${col}`);
            }
          }
          
          // Diagonal captures
          if (board[row + dir]) {
            if (board[row + dir][col - 1] && board[row + dir][col - 1] !== '.' && !isCurrentPlayerPiece(board[row + dir][col - 1]))
              moves.push(`${row + dir}-${col - 1}`);
            if (board[row + dir][col + 1] && board[row + dir][col + 1] !== '.' && !isCurrentPlayerPiece(board[row + dir][col + 1]))
              moves.push(`${row + dir}-${col + 1}`);
          }
          
          // En passant
          if (enPassantTarget && enPassantTarget.row === row + dir) {
            if (enPassantTarget.col === col - 1 || enPassantTarget.col === col + 1) {
              moves.push(`${enPassantTarget.row}-${enPassantTarget.col}-ep`);
            }
          }
          break;
          
        case 'r': addLineMoves(moves, row, col, [[0,1],[0,-1],[1,0],[-1,0]]); break;
        case 'b': addLineMoves(moves, row, col, [[1,1],[1,-1],[-1,1],[-1,-1]]); break;
        case 'q': addLineMoves(moves, row, col, [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]); break;
        case 'n':
          const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
          for (let [dr, dc] of knightMoves) {
            const nr = row + dr, nc = col + dc;
            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && (board[nr][nc] === '.' || !isCurrentPlayerPiece(board[nr][nc])))
              moves.push(`${nr}-${nc}`);
          }
          break;
        case 'k':
          for (let dr = -1; dr <= 1; dr++)
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = row + dr, nc = col + dc;
              if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && (board[nr][nc] === '.' || !isCurrentPlayerPiece(board[nr][nc])))
                moves.push(`${nr}-${nc}`);
            }
          break;
      }
      return moves;
    }

    function addLineMoves(moves, row, col, directions) {
      for (let [dr, dc] of directions) {
        for (let i = 1; i < 8; i++) {
          const nr = row + dr * i, nc = col + dc * i;
          if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
          if (board[nr][nc] === '.') {
            moves.push(`${nr}-${nc}`);
          } else {
            if (!isCurrentPlayerPiece(board[nr][nc])) moves.push(`${nr}-${nc}`);
            break;
          }
        }
      }
    }

    function applyGravityWithAnimation(callback) {
      let hasMovement = true;
      let animationCount = 0;

      function processGravityRound() {
        if (!hasMovement) {
          if (callback) callback();
          return;
        }

        hasMovement = false;
        const fallingPieces = [];

        // Process all columns for gravity
        for (let col = 0; col < 8; col++) {
          // Handle white pieces falling down to rank 4
          for (let row = 0; row <= 3; row++) {
            const piece = board[row][col];
            if (piece !== '.' && piece.toLowerCase() !== 'p') {
              // Find the lowest available position for this piece
              let target = row;
              while (target + 1 <= 3 && board[target + 1][col] === '.') {
                target++;
              }
              if (target !== row) {
                fallingPieces.push({ from: row, to: target, col, piece });
                hasMovement = true;
              }
            }
          }

          // Handle black pieces falling up to rank 5
          for (let row = 7; row >= 4; row--) {
            const piece = board[row][col];
            if (piece !== '.' && piece.toLowerCase() !== 'p') {
              // Find the highest available position for this piece
              let target = row;
              while (target - 1 >= 4 && board[target - 1][col] === '.') {
                target--;
              }
              if (target !== row) {
                fallingPieces.push({ from: row, to: target, col, piece });
                hasMovement = true;
              }
            }
          }
        }

        if (fallingPieces.length === 0) {
          if (callback) callback();
          return;
        }

        // Apply all movements for this round
        fallingPieces.forEach(({ from, to, col, piece }) => {
          board[from][col] = '.';
          board[to][col] = piece;
        });

        updateBoard();
        animationCount++;

        // Continue processing gravity after a short delay
        setTimeout(() => {
          processGravityRound();
        }, 150);
      }

      processGravityRound();
    }

    const pieceEmojis = {
      'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
      'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };

    function resetGame() {
      initializeBoard();
      selectedSquare = null;
      currentPlayer = 'white';
      possibleMoves = [];
      gameOver = false;
      document.getElementById('promotion-modal').classList.add('hidden');
      document.getElementById('turn-info').style.color = '#4a90e2';
      updateTurnInfo();
      updateBoard();
    }

    initializeBoard();
    createBoard();
    updateBoard();
  </script>
</body></html>
